#include"DSP281x_Device.h"
#include"DSP281x_Examples.h"
#include"PI.h"


/*******************************宏定义***********************************/
#define T0          0.0002                  //离散化采样周期0.0002s
#define VolKp       2                       //电压调节Kp系数值
#define VolKi       1                       //Ki系数值
#define VolRef      380                     //基准电压
#define VolLimit    400                     //电压限制值
#define EleKp       2                       //电流调节Kp系数值
#define EleKi       1                       //Ki系数值
#define EleRef      20                      //基准电流
#define EleLimit    25                      //电流限制值

#define Key_CE      GpioDataRegs.GPADAT.bit.GPIOA12     //按键
#define Key_CP      GpioDataRegs.GPADAT.bit.GPIOA13
#define Key_VA      GpioDataRegs.GPADAT.bit.GPIOA14

#define Beep        GpioDataRegs.GPBDAT.bit.GPIOB14     //蜂鸣器
#define LCD_RS      GpioDataRegs.GPBDAT.bit.GPIOB8      //LCD控制引脚
#define LCD_RW      GpioDataRegs.GPBDAT.bit.GPIOB9
#define LCD_E       GpioDataRegs.GPBDAT.bit.GPIOB10
#define LCD_CS1     GpioDataRegs.GPBDAT.bit.GPIOB11
#define LCD_CS2     GpioDataRegs.GPBDAT.bit.GPIOB12
#define LCD_RET     GpioDataRegs.GPBDAT.bit.GPIOB13
#define disp_off    0x3e   
#define disp_on     0x3f   
#define disp_x      0xb8   
#define disp_z      0xc0   
#define disp_y      0x40   
#define comm        0   
#define dat         1   
#define data_ora    GpioDataRegs.GPBDAT.all
#define uchar       unsigned char

/******************************全局变量**********************************/
float32 VolOutput[3],EleOutput[3];          //用于存储PI调节后的输出值
float32 adc[16];                            //用于存储ADC转换结果
float32 Input[16],Output[16];               //用于保存16个通道实际的输入电压，以及滤波处理后的采样结果
float CalGain,CalOffset;                    //校正算法用于计算的增益和偏移
Uint16 sciatxbuf[8],sciarxbuf[8],scibtxbuf[8],scibrxbuf[8];
Uint16 spitxbuf[8],spirxbuf[8];             //用于储存通信数据
Uint32 ecantxbuf[2],ecanrxbuf[2];

PI VOL = PI_DEFAULTS;                       //电压调节,电压跟踪基准380V，T2中断
PI ELE = PI_DEFAULTS;                       //电流调节

Uint16 N = 400,i = 0;                       //载波比
float M = 0.8;                              //调制度
//预存正弦值列表
float sina[30]={ 0.000000,    0.104528,    0.207911,    0.309016,    0.406737,
                 0.500000,    0.587785,    0.669131,    0.743145,    0.809017,
		         0.866025,    0.913545,    0.951057,    0.978148,    0.994522,
		         1.000000,    0.994522,    0.978148,    0.951057,    0.913545,
		         0.866025,    0.809017,    0.743145,    0.669131,    0.587785,
		         0.500000,    0.406737,    0.309016,    0.207911,    0.104528};

float sinb[30]={ 0.866025,    0.809017,    0.743145,    0.669131,    0.587785,
                 0.500000,    0.406737,    0.309016,    0.207911,    0.104528,
		         0.000000,   -0.104528,   -0.207911,   -0.309016,   -0.406737,
		        -0.500000,   -0.587785,   -0.669131,   -0.743145,   -0.809017,
		        -0.866025,   -0.913545,   -0.951057,   -0.978148,   -0.994522,
		        -1.000000,   -0.994522,   -0.978148,   -0.951057,   -0.913545};

Uint16 T2count = 0;                         //T2中断计数

float32 Capbuf[2];                          //用于存储过零检测数值
float32 CapOutput[2];                       //用于存储捕获中断PI调节的输出值


//LCD显示字符   
uchar  hz11[]={    
0x40,0x40,0x20,0x20,0x50,0x48,0x44,0xC3,0x44,0x48,0x50,0x50,0x20,0x60,0x20,0x00,   
0x40,0x40,0x42,0x42,0x4A,0x72,0x42,0x7F,0x42,0x62,0x5A,0x42,0x42,0x40,0x40,0x00,   
0x00,0xFE,0x12,0xFE,0x00,0xFE,0x12,0xFE,0x00,0xFC,0x0E,0x35,0x44,0x7C,0x00,0x00,   
0x20,0x1F,0x21,0x7F,0x20,0x1F,0x41,0x7F,0x08,0x09,0x09,0x29,0x49,0x21,0x1F,0x00,     
0x10,0x12,0x92,0x72,0xFE,0x51,0x91,0x00,0x22,0xCC,0x00,0x00,0xFF,0x00,0x00,0x00,   
0x04,0x02,0x01,0x00,0xFF,0x00,0x04,0x04,0x04,0x02,0x02,0x02,0xFF,0x01,0x01,0x00,   
0x08,0x08,0x88,0xFF,0x48,0x28,0x00,0xC8,0x48,0x48,0x7F,0x48,0xC8,0x48,0x08,0x00,   
0x01,0x41,0x80,0x7F,0x00,0x40,0x40,0x20,0x13,0x0C,0x0C,0x12,0x21,0x60,0x20,0x00,    
0xFF,0xFF,0x01,0xDD,0xD5,0x4D,0x9C,0x01,0x9D,0x4D,0x55,0xDD,0x01,0xFF,0xFF,0xFF,   
0x7F,0x7B,0xBA,0xBB,0xDA,0xEB,0xF3,0xF8,0xF3,0xEB,0xDA,0xDB,0xBA,0x3B,0xBB,0xFF,   
0xFF,0xFD,0xFD,0x0D,0xED,0xED,0xED,0xED,0x0D,0xFD,0xFD,0xFD,0x01,0xFD,0xFD,0xFF,   
0xFF,0xFF,0xFF,0xF8,0xFD,0xFD,0xFD,0xFD,0xF8,0xEF,0xDF,0xBF,0xC0,0xFF,0xFF,0xFF,     
0xEF,0xEF,0xEF,0x00,0x6F,0xAF,0xFF,0xB7,0x76,0xF5,0xF1,0xF7,0x17,0xB7,0xF7,0xFF,   
0xFD,0xBD,0x7E,0x80,0xFF,0xDF,0xDF,0xDF,0xDE,0xC1,0xDF,0xC3,0xDC,0xDF,0xDF,0xFF,      
0xEF,0x9E,0xF9,0x1F,0xE7,0x7B,0x1B,0xE3,0x7B,0x9A,0x41,0xDB,0x5B,0x9B,0xFB,0xFF,   
0xFB,0xFB,0x00,0xFF,0xFE,0xFF,0x00,0xBE,0xDE,0xED,0xF3,0xE4,0x9E,0x3F,0xBF,0xFF};   
uchar hz12[]={    
0x00,0x04,0x84,0x44,0xE4,0x34,0x2C,0x27,0x24,0x24,0x24,0xE4,0x04,0x04,0x04,0x00,   
0x02,0x01,0x00,0x00,0xFF,0x09,0x09,0x09,0x29,0x49,0xC9,0x7F,0x00,0x00,0x00,0x00,    
0xFE,0x02,0x32,0x4E,0x82,0x00,0xFE,0x4A,0xCA,0x4A,0x4A,0x4A,0x7E,0x00,0x00,0x00,   
0xFF,0x00,0x02,0x04,0x03,0x00,0xFF,0x40,0x20,0x03,0x0C,0x12,0x21,0x60,0x20,0x00,      
0x00,0x00,0x80,0x40,0x30,0x0E,0x84,0x00,0x00,0x0E,0x10,0x60,0xC0,0x80,0x80,0x00,   
0x00,0x01,0x20,0x70,0x28,0x24,0x23,0x31,0x10,0x10,0x14,0x78,0x30,0x01,0x00,0x00,     
0x00,0x10,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x12,0x02,0x02,0xFE,0x00,0x00,   
0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x0F,0x00,0x20,0x40,0x3F,0x00,0x00,     
0xFF,0xFF,0xFF,0xFF,0x81,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0x81,0xFF,0xFF,0xFF,0xFF,   
0xFF,0x80,0xDA,0xDA,0xDA,0xDA,0x80,0xFF,0xFF,0x80,0xDA,0xDA,0xDA,0xDA,0x80,0xFF,     
0xFF,0xFF,0xFF,0xC1,0xD5,0x15,0xD5,0xD5,0xD5,0x15,0xD5,0xC1,0xFF,0xFF,0xFF,0xFF,   
0xDF,0xDE,0xDD,0xD3,0xDF,0xC0,0xDF,0xDF,0xDF,0xC0,0xD7,0xDB,0xDC,0xDF,0xDF,0xFF,    
0xFF,0xDF,0xDF,0xDD,0xDD,0xDD,0xDD,0x1D,0xDD,0xDD,0xDD,0xDD,0xDD,0xDF,0xDF,0xFF,   
0xEF,0xF7,0xFB,0xFC,0xFF,0xBF,0x7F,0x80,0xFF,0xFF,0xFE,0xFD,0xF3,0xE7,0xFF,0xFF,     
0xBF,0xBF,0xB0,0xB6,0xB6,0x36,0x30,0x8F,0x3F,0x30,0xB6,0xA6,0x96,0xB0,0xFF,0xFF,   
0xFD,0xFD,0x81,0xBA,0xBA,0xBB,0x83,0xFF,0x83,0xBB,0xBA,0xBA,0x81,0xF9,0xFD,0xFF};   
uchar hz31[]={   
0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,   
0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,      
0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,   
0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,    
0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,    
0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,     
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,    
0xE7,0xF7,0xF7,0x07,0xF7,0xF7,0xE7,0xFF,0xFF,0xFF,0xDF,0xC0,0xDF,0xFF,0xFF,0xFF,     
0xF7,0x07,0x77,0x77,0x17,0xF7,0xEF,0xFF,0xDF,0xC0,0xDF,0xDF,0xDC,0xDF,0xE7,0xFF,    
0xF7,0x07,0xF7,0xFF,0xFF,0xFF,0xFF,0xFF,0xDF,0xC0,0xDF,0xDF,0xDF,0xDF,0xCF,0xFF,     
0xFF,0xFF,0xFF,0x3F,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xCF,0xFF,0xFF,0xFF,    
0xFF,0x1F,0xEF,0xF7,0xF7,0xEF,0x1F,0xFF,0xFF,0xF0,0xEF,0xDF,0xDF,0xEF,0xF0,0xFF,   
0xFF,0xC7,0xF7,0xF7,0x37,0xC7,0xF7,0xFF,0xFF,0xFF,0xFF,0xC0,0xFF,0xFF,0xFF,0xFF,     
0xFF,0x07,0xF7,0x77,0x77,0xF7,0xF7,0xFF,0xFF,0xE6,0xDE,0xDF,0xDF,0xEE,0xF1,0xFF,    
0xFF,0x8F,0x77,0xF7,0xF7,0x77,0x8F,0xFF,0xFF,0xE3,0xDD,0xDE,0xDE,0xDD,0xE3,0xFF};   
uchar hz32[]={     
0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,     
0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,     
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,     
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,     
0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,    
0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,      
0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,     
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,     
0xFF,0x8F,0xF7,0xF7,0xF7,0x77,0x8F,0xFF,0xFF,0xCF,0xD7,0xDB,0xDD,0xDE,0xCF,0xFF,      
0xFF,0x8F,0xF7,0xF7,0xF7,0x77,0x8F,0xFF,0xFF,0xCF,0xD7,0xDB,0xDD,0xDE,0xCF,0xFF,     
0xFF,0x1F,0xEF,0x77,0x77,0xE7,0xFF,0xFF,0xFF,0xF0,0xEE,0xDF,0xDF,0xEE,0xF1,0xFF,     
0xFF,0xCF,0xF7,0x77,0x77,0xB7,0xCF,0xFF,0xFF,0xE7,0xDF,0xDF,0xDF,0xEE,0xF1,0xFF,    
0xFF,0x8F,0x77,0xF7,0xF7,0x77,0x8F,0xFF,0xFF,0xE3,0xDD,0xDE,0xDE,0xDD,0xE3,0xFF,     
0xFF,0x07,0xF7,0x77,0x77,0xF7,0xF7,0xFF,0xFF,0xE6,0xDE,0xDF,0xDF,0xEE,0xF1,0xFF,   
0xFF,0x8F,0x77,0xF7,0xF7,0x77,0x8F,0xFF,0xFF,0xE3,0xDD,0xDE,0xDE,0xDD,0xE3,0xFF};   
uchar tab31[]={      
0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x48,0xD4,0xB4,0x62,0xC2,0x82,0x02,   
0x02,0x02,0x02,0x84,0xC4,0xE0,0xA0,0xE0,0x60,0x20,0x20,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0xFE,0x01,0x00,0x04,0x0D,0x1B,0x36,0x6D,0xDB,0xF6,0xED,0xFB,   
0xFE,0xFE,0xFF,0x7F,0x1F,0x07,0x01,0x00,0x10,0x10,0xF0,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x08,0x10,0x20,0x40,0x40,0x80,0x83,0xFF,0xFF,   
0xFF,0xFF,0x83,0x40,0x40,0x20,0x10,0x08,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,   
0x7C,0x44,0xEC,0x00,0x7C,0x44,0x7C,0x00,0x7C,0x40,0x40,0x00,0x7C,0x44,0x38,0x00,   
0x7C,0x14,0x1C,0x00,0x78,0x24,0x78,0x00,0x7C,0x40,0x40,0x00,0x7C,0x18,0x18,0x7C};   
uchar tab32[]={    
0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xBF,0xDF,0xEF,0xB7,0x2B,0x4B,0x9D,0x3D,0x7D,0xFD,   
0xFD,0xFD,0xFD,0x7B,0x3B,0x1F,0x5F,0x1F,0x9F,0xDF,0xDF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0x01,0xFE,0xFF,0xFB,0xF2,0xE4,0xC9,0x92,0x24,0x09,0x12,0x04,   
0x01,0x01,0x00,0x80,0xE0,0xF8,0xFE,0xFF,0xEF,0xEF,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFB,0xF7,0xEF,0xDF,0xBF,0xBF,0x7F,0x7C,0x00,0x00,   
0x00,0x00,0x7C,0xBF,0xBF,0xDF,0xEF,0xF7,0xFB,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0x83,0xBB,0x13,0xFF,0x83,0xBB,0x83,0xFF,0x83,0xBF,0xBF,0xFF,0x83,0xBB,0xC7,0xFF,   
0x83,0xEB,0xE3,0xFF,0x87,0xDB,0x87,0xFF,0x83,0xBF,0xBF,0xFF,0x83,0xE7,0xE7,0x83};   
uchar tab5[]={     
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,   
0xC0,0xE0,0x70,0x00,0x00,0x80,0xC0,0xE0,0xF0,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,   
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xF0,0x78,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,   
0xC0,0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,   
0xE0,0xE0,0xE0,0xC0,0xC0,0xC0,0xC0,0xC0,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xFF,0xFE,0xFE,0xFC,0xCF,0xCF,   
0xFF,0xFF,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x7E,0x7F,0x3F,0x3F,0x3F,0x3E,   
0x1E,0x1E,0x0E,0x0E,0x07,0x03,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,   
0xF0,0xF0,0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFB,0xFB,0xFB,0xBB,0xBB,0xB9,0xB9,0xB9,0xB9,0xB9,0x39,0x39,0x39,0x39,0x39,   
0x71,0x71,0x71,0x71,0xE3,0xE3,0xE3,0xC3,0xC7,0x87,0x87,0x07,0x0F,0x1F,0x1F,0x3E,   
0x7C,0xF8,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x80,0xC0,0xE0,0xF0,0xF8,0xF8,0xF8,0xFB,0xF9,0xFC,0xFC,0xFC,0xFE,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,   
0xFE,0xFE,0xFC,0xFC,0xF0,0xF0,0xE0,0x81,0x03,0x07,0x07,0x1F,0xFE,0xF8,0x00,0x00,   
0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,   
0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xDF,0xBF,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB,   
0xFB,0xF3,0xE7,0x0F,0x3F,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x03,0x01,0x00,0x00,0x00,   
0x04,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   
0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x1F,0x01,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,   
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,0x0F,0x00,0x03,0xFF,0xFF,0x7F,0x3F,0x0F,   
0x07,0x07,0x01,0x00,0xF8,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x1F,0x3F,   
0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,0x3F,0x1F,   
0x1F,0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x07,   
0x03,0x03,0x0F,0x10,0x00,0x00,0x00,0x3C,0x0F,0x07,0x07,0x07,0x03,0x00,0x00,0x1E,   
0x07,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x80,0xC0,0x61,0x33,0x1F,0x1F,0x1F,0x73,0x80,0x80,0x01,0x01,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x49,0x39,0x13,0x13,0x0F,0x14,0x04,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x14,0x0C,0x04,   
0x06,0x06,0x03,0x09,0x00,0x00,0x00,0x07,0x07,0x00,0x00,0x02,0x00,0x00,0x00,0x04,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
void delay2 (Uint16 us)   
{   
  while(us--);   
}   
void delay1 (Uint16 ms)   
{   
  Uint16 i,j;   
  for(i=0;i<ms;i++)   
  for(j=0;j<1000;j++)   
  ;   
}
void chk_busy (void)   
{   
  data_ora=0xff;   
  LCD_RS=0;   
  LCD_E=1;   
  ;   
  LCD_E=1;     
  LCD_E=0;   
}

void wr_lcd (uchar dat_comm,uchar content)   
{   
  chk_busy ();   
  LCD_RS=dat_comm;   
  LCD_RW=0;   
  data_ora=content;   
  LCD_E=1;      
  LCD_E=0;   
}
uchar rd_lcd ()   
{   
  uchar rddata;   
  chk_busy ();   
  LCD_RS=1;   
  LCD_RW=1;   
  LCD_E=1;     
  rddata=data_ora;   
  LCD_E=0;   
  return rddata;   
}
void lat_disp (uchar data1,uchar data2)   
{   
  uchar i,j;   
  LCD_CS1=1;
  LCD_CS2=1;   
  wr_lcd (comm,disp_on);   
  for(j=0;j<8;j++)   
  {   
    wr_lcd (comm,disp_x+j);   
    wr_lcd (comm,disp_z);   
    wr_lcd (comm,disp_y);   
    for(i=0;i<32;i++)   
    {   
      wr_lcd (dat,data1);   
      wr_lcd (dat,data2);   
    }   
  }   
}
void img_disp (uchar code *img)   
{   
  uchar i,j;   
  for(j=0;j<8;j++)   
  {   
    LCD_CS1=1;
    LCD_CS2=0;   
    wr_lcd (comm,disp_on);   
    wr_lcd (comm,disp_x+j);   
    wr_lcd (comm,disp_z);   
    wr_lcd (comm,disp_y);   
    for(i=0;i<64;i++)   
      wr_lcd (dat,img[j*128+i]);   
    LCD_CS1=0;
    LCD_CS2=1;   
    wr_lcd (comm,disp_on);   
    wr_lcd (comm,disp_x+j);   
    wr_lcd (comm,disp_z);   
    wr_lcd (comm,disp_y);   
    for(i=64;i<128;i++)   
      wr_lcd (dat,img[j*128+i]);   
  }   
}
void chn_disp (uchar x,uchar y,uchar xl,uchar yl,uchar row_xl,uchar row_yl,uchar *chn)   
{   
  uchar i,j,k,l,a;   
  wr_lcd (comm,disp_on);   
  for(l=0;l<row_xl;l++)   
  {   
    for(k=0;k<row_yl;k++)   
    {   
      for(j=0;j<xl;j++)   
      {   
        wr_lcd (comm,disp_x+x+l*xl+j);   
        wr_lcd (comm,disp_z);   
        wr_lcd (comm,disp_y+y+k*yl);   
        a=l*xl*yl*row_yl+k*xl*yl+j*yl;   
        for(i=0;i<yl;i++)   
          wr_lcd (dat,chn[a+i]);   
      }   
    }   
  }   
}
void init_lcd (void)   
{   
  LCD_RET=0;   
  delay(50);   
  LCD_RET=1;   
  LCD_CS1=1;
  LCD_CS2=1;   
  wr_lcd (comm,disp_off);   
  wr_lcd (comm,disp_on);   
}
void disp1 (void)   
{   
  lat_disp(0x00,0x00);   
  LCD_CS1=1;
  LCD_CS2=0;   
  chn_disp (0,0,2,16,2,4,hz11);   
  LCD_CS1=0;
  LCD_CS2=1;   
  chn_disp (0,0,2,16,2,4,hz12);   
  LCD_CS1=1;
  LCD_CS2=0;   
  chn_disp (4,0,2,8,2,8,hz31);   
  LCD_CS1=0;
  LCD_CS2=1;   
  chn_disp (4,0,2,8,2,8,hz32);   
} 
void disp3 (void)   
{   
  LCD_CS1=1;
  LCD_CS2=1;   
  chn_disp (0,0,4,32,1,1,tab31);   
  chn_disp (0,32,4,32,1,1,tab32);   
  chn_disp (4,0,4,32,1,1,tab32);   
  chn_disp (4,32,4,32,1,1,tab31);   
}


//74hc165读取按键值
void delay(void)
{
    unsigned char i,j;
    for(i = 250;i > 0;i--)
    for(j = 200;j > 0;j--);
}
uchar HC165(void)
{
    unsigned char i;
    unsigned char Temp;
    Key_CP = 1;
    Key_CE = 0;        //HC165读按键
    Key_CE = 1;        //暂停HC165读按键
    Temp = 0;
    if(Key_VA == 1) Temp |= 0x01;
    for(i = 0;i < 7;i++)
    {    
        Key_CP = 0;  
        Key_CP = 1;  
        Temp <<= 1;
        if(Key_VA == 1) 
        {
            Temp |= 0x01;
        }
    }
    Key_CE = 0;
    return(Temp);
}





/******************************函数声明*********************************/
void sequence (float a[],int n);
void ecantx(void);
interrupt void eva_t1_isr(void);
interrupt void eva_t2_isr(void);
interrupt void evb_t3_isr(void);
interrupt void evb_t4_isr(void);
interrupt void evb_cap4_isr(void);
interrupt void adc_isr(void);
interrupt void sciatxfifo_isr(void);
interrupt void sciarxfifo_isr(void);
interrupt void scibtxfifo_isr(void);
interrupt void scibrxfifo_isr(void);
interrupt void spitxfifo_isr(void);
interrupt void spirxfifo_isr(void);
interrupt void ecanrx_isr(void);


/********************************主函数*******************************/
void main(void)
{
    Uint16 i;
    

    InitSysCtrl();
    DINT;
    IER = 0x0000;
    IFR = 0x0000;
    InitPieCtrl();
    InitPieVectTable();
    InitEv();
    InitGpio();
    InitAdc();
    InitSci();
    InitSpi();
    InitECan();
    init_lcd();
    EALLOW;
    PieVectTable.T1PINT = &eva_t1_isr;
    PieVectTable.T2PINT = &eva_t2_isr;
    PieVectTable.T3PINT = &evb_t3_isr;
    PieVectTable.T4PINT = &evb_t4_isr;
    PieVectTable.CAPINT4 = &evb_cap4_isr;
    
    PieVectTable.ADCINT = &adc_isr;
    
    PieVectTable.RXAINT = &sciarxfifo_isr;
    PieVectTable.TXAINT = &sciatxfifo_isr;
    PieVectTable.RXBINT = &scibrxfifo_isr;
    PieVectTable.TXBINT = &scibtxfifo_isr;
    
    PieVectTable.SPIRXINTA = &spirxfifo_isr;
    PieVectTable.SPITXINTA = &spitxfifo_isr;

    PieVectTable.ECAN0INTA = &ecanrx_isr;
    EDIS;
    
    for(i=0;i<16;i++)
        {
            Input[i] = 0;
            Output[i] = 0;
        }
    Input[0] = 0.420;               //参考电压1
    Input[8] = 1.653;

    PieCtrlRegs.PIEIER2.bit.INTx4 = 1;      //使能周期中断T1，T2，T3，T4
    PieCtrlRegs.PIEIER3.bit.INTx1 = 1;
    PieCtrlRegs.PIEIER4.bit.INTx4 = 1;
    PieCtrlRegs.PIEIER5.bit.INTx1 = 1;
    IER |= (M_INT2 | M_INT3 | M_INT4 | M_INT5);

    PieCtrlRegs.PIEIER4.bit.INTx1 = 1;      //使能捕获中断CAP4
    IER |= M_INT4;

    PieCtrlRegs.PIEIER1.bit.INTx6 = 1;      //使能PIE模块中的ADC采样中断
    IER |= M_INT1;

    PieCtrlRegs.PIECRTL.bit.ENPIE = 1;
    PieCtrlRegs.PIEIER9.bit.INTx1 = 1;      //使能PIE模块中的SCI中断
    PieCtrlRegs.PIEIER9.bit.INTx2 = 1;
    PieCtrlRegs.PIEIER9.bit.INTx3 = 1;
    PieCtrlRegs.PIEIER9.bit.INTx4 = 1;
    IER |= M_INT9;

    PieCtrlRegs.PIECRTL.bit.ENPIE = 1;      //使能PIE模块中的SPI中断
    PieCtrlRegs.PIEIER6.bit.INTx1 = 1;
    PieCtrlRegs.PIEIER6.bit.INTx2 = 1;
    IER |= M_INT6;

    PieCtrlRegs.PIEIER9.bit.INTx5 = 1;      //使能PIE模块中的ECAN中断
    IER |= M_INT9;
    
    EINT;
    ERTM;
    EvaRegs.T1CON.bit.TENABLE = 1;          //启动T1计数
    EvaRegs.T2CON.bit.TENABLE = 1;          //T2
    EvbRegs.T3CON.bit.TENABLE = 1;
    EvbRegs.T4CON.bit.TENABLE = 1;

    while(1)
        {
        }
}

void sequence(float a [ ], int n)           //冒泡排序，将数组元素有小到大排列
{
    Uint16 i = 0,j = 0;
    float32 temp = 0;
    for(i = 0;i < n;i++)
        {
            for(j = j+1;j <= n;j++)
                {
                    if(a[i]>a[j])
                        {
                            temp = a[i];
                            a[i] = a[j];
                            a[j] = temp;
                        }
                }
        }
}

void ecantx(void)
{
    ECanaRegs.CANTRS.all = 0x01000001;      //发送请求置位，邮箱开始发送数据
    while(ECanaRegs.CANTA.all == 0);        //等待邮箱发送完成
    ECanaRegs.CANTA.all = 0x00000001;       //复位发送成功标志位
    ECanaMboxes.MBOX0.MDL.all = ecantxbuf[0];
    ECanaMboxes.MBOX0.MDH.all = ecantxbuf[1];
}



//T1周期中断，中断周期50us，对母线电压进行PI调节
//得到输出电流基准，然后对输出电流进行PI调节，跟踪
//电流基准，产生SPWM信号驱动逆变器,载波频率20kHz，
//载波比400，因此调制波形正弦波的频率为50Hz,调制度0.8
interrupt void eva_t1_isr(void)
{
    VOL.Kp = VolKp;                         //初始化PI控制器
    VOL.Ki = VolKi;
    VOL.T = T0;
    VOL.OutMax = VolLimit;
    //调节电压值
    VOL.Ref = VolRef;                       //电压给定值
    VOL.Fdb = Input[1];                     //电压反馈值
    VOL.Err = VOL.Ref - VOL.Fdb;            //偏差
    pi_calc(&VOL);                          //函数调用，启动PI计算
    VolOutput[0] = VOL.Out;                 //读取PI控制器的输出

    ELE.Kp = EleKp;
    ELE.Ki = EleKi;
    ELE.T = T0;
    ELE.OutMax = EleLimit;
    //调节电流值
    ELE.Ref = EleRef;
    ELE.Fdb = Input[9];
    ELE.Err = ELE.Ref - ELE.Fdb;
    pi_calc(&ELE);
    EleOutput[0] = ELE.Out;

    if((i>=0)&&(i<N/2))                     //前半周期
        {
            EvaRegs.CMPR1 = EvaRegs.T1PR * ((1.0 + M*sina[i])/2.0);
            EvaRegs.CMPR2 = EvaRegs.T1PR * ((1.0 + M*sinb[i])/2.0);
        }
    if((i>=N/2)&&(i<N))
        {
            EvaRegs.CMPR1 = EvaRegs.T1PR * ((1.0 - M*sina[i-30])/2.0);
            EvaRegs.CMPR2 = EvaRegs.T1PR * ((1.0 - M*sinb[i-30])/2.0);
        }
    i++;
    if(i>=N)
        i = 0;
    
    PieCtrlRegs.PIEACK.bit.ACK2 = 1;        //响应同组中断
    EvaRegs.EVAIFRA.bit.T1PINT = 1;         //清除中断标志位
}

//T2周期中断，中断周期100ms，进行MPPT计算，刷新电压基准值
interrupt void eva_t2_isr(void)
{
    T2count++;
    if(T2count == 100)
        {
            VOL.Kp = VolKp;                         //初始化PI控制器
            VOL.Ki = VolKi;
            VOL.T = T0;
            VOL.OutMax = VolLimit;
            //调节电压值
            VOL.Ref = VolRef;                       //电压给定值
            VOL.Fdb = Input[1];                     //电压反馈值
            VOL.Err = VOL.Ref - VOL.Fdb;            //偏差
            pi_calc(&VOL);                          //函数调用，启动PI计算
            VolOutput[1] = VOL.Out;                 //读取PI控制器的输出
        }
    if(T2count>100)
        T2count = 0;

    EvaRegs.EVAIFRB.bit.T2PINT = 1;
    PieCtrlRegs.PIEACK.bit.ACK3 = 1;
}

//T3周期中断，中断周期10ms，对直流侧输入电压进行PI调节
interrupt void evb_t3_isr(void)
{
    
    VOL.Kp = VolKp;                         //初始化PI控制器
    VOL.Ki = VolKi;
    VOL.T = T0;
    VOL.OutMax = VolLimit;
    //调节电压值
    VOL.Ref = VolRef;                       //电压给定值
    VOL.Fdb = Input[1];                     //电压反馈值
    VOL.Err = VOL.Ref - VOL.Fdb;            //偏差
    pi_calc(&VOL);                          //函数调用，启动PI计算
    VolOutput[2] = VOL.Out;                 //读取PI控制器的输出

    EvbRegs.EVBIFRA.bit.T3PINT = 1;
    PieCtrlRegs.PIEACK.bit.ACK4 = 1;
}

interrupt void evb_t4_isr(void)
{
    ELE.Kp = EleKp;
    ELE.Ki = VolKi;
    ELE.T = T0;
    ELE.OutMax = EleLimit;
    //调节电流值
    ELE.Ref = EleRef;
    ELE.Fdb = Input[10];
    ELE.Err = ELE.Ref - ELE.Fdb;
    pi_calc(&ELE);
    EleOutput[1] = ELE.Out;

    EvbRegs.EVBIFRB.bit.T4PINT = 1;
    PieCtrlRegs.PIEACK.bit.ACK5 = 1;
}

//对电网进行过零检测，读出周期过零点数值，滤波后作为参考输入相位1
//读出电流周期过零点数值，作为反馈相位2，对1-2进行PI调节
interrupt void evb_cap4_isr(void)
{
    Capbuf[0] = EvbRegs.CAP4FIFO;
    Capbuf[1] = EvbRegs.CAP4FIFO;

    VOL.Kp = VolKp;                         //初始化PI控制器
    VOL.Ki = VolKi;
    VOL.T = T0;
    VOL.OutMax = VolLimit;
    //调节电压值
    VOL.Ref = VolRef;                       //电压给定值
    VOL.Fdb = Capbuf[0];                    //电压反馈值
    VOL.Err = VOL.Ref - VOL.Fdb;            //偏差
    pi_calc(&VOL);                          //函数调用，启动PI计算
    CapOutput[0] = VOL.Out;                 //读取PI控制器的输出

    ELE.Kp = EleKp;
    ELE.Ki = EleKi;
    ELE.T = T0;
    ELE.OutMax = EleLimit;
    //调节电流值
    ELE.Ref = EleRef;
    ELE.Fdb = Capbuf[1];
    ELE.Err = ELE.Ref - ELE.Fdb;
    pi_calc(&ELE);
    CapOutput[1] = ELE.Out;

    EvbRegs.EVBIFRC.bit.CAP4INT = 1;
    PieCtrlRegs.PIEACK.bit.ACK4 = 1;
}


interrupt void adc_isr(void)                //ADC中断函数
{
    Uint16 m,n;
    
    Uint16 SampleCount = 0;
    float32 adca0[10];
    float32 adca1[10];
    float32 adca2[10];
    float32 adca3[10];
    float32 adcb0[10];                      //用于保存ADCB通道的10次采样结果
    float32 adcb1[10];
    float32 adcb2[10];
    float32 adcb3[10];
    SampleCount ++;                         //采样计数器计数
    //读取转换结果
    adc[0] = ((float)AdcRegs.ADCRESULT0)*3.0/65520;
    adc[1] = ((float)AdcRegs.ADCRESULT1)*3.0/65520;
    adc[2] = ((float)AdcRegs.ADCRESULT2)*3.0/65520;
    adc[3] = ((float)AdcRegs.ADCRESULT3)*3.0/65520;
    adc[8] = ((float)AdcRegs.ADCRESULT8)*3.0/65520;
    adc[9] = ((float)AdcRegs.ADCRESULT9)*3.0/65520;
    adc[10] = ((float)AdcRegs.ADCRESULT10)*3.0/65520;
    adc[11] = ((float)AdcRegs.ADCRESULT11)*3.0/65520;
    //将每个通道采样得到的数据存入数组中，等待数据处理
    adca0[SampleCount - 1] = adc[0];
    adca1[SampleCount - 1] = adc[1];
    adca2[SampleCount - 1] = adc[2];
    adca3[SampleCount - 1] = adc[3];
    adcb0[SampleCount - 1] = adc[8];
    adcb1[SampleCount - 1] = adc[9];
    adcb2[SampleCount - 1] = adc[10];
    adcb3[SampleCount - 1] = adc[11];
    if(SampleCount == 10)
        {
            sequence(adca0,10);
            sequence(adca1,10);
            sequence(adca2,10);
            sequence(adca3,10);
            sequence(adcb0,10);
            sequence(adcb1,10);
            sequence(adcb2,10);
            sequence(adcb3,10);
            for(m=3;m<7;m++)         //中值滤波法
                {
                    Output[0] = Output[0] + adca0[m];
                    Output[1] = Output[1] + adca1[m];
                    Output[2] = Output[2] + adca2[m];
                    Output[3] = Output[3] + adca3[m];
                    Output[8] = Output[8] + adcb0[m];
                    Output[9] = Output[9] + adcb1[m];
                    Output[10] = Output[10] + adcb2[m];
                    Output[11] = Output[11] + adcb3[m];
                }
            SampleCount = 0;                //清采样计数器，进入新的连续10次的采样
            for(n = 0;n<16;n++)      
                Output[n] = Output[n]/4;    //计算4个数据的平均值
            CalGain = (Input[8] - Input[0])/(Output[8] - Output[0]);
            CalOffset = (Input[8] * Output[0] - Input[0] * Output[8])/(Output[8] - Output[0]);
            //通过采样数据来计算实际的输入
            Input[1] = Output[1] * CalGain - CalOffset;     //直流电压采样值
            Input[2] = Output[2] * CalGain - CalOffset;     //逆变电压采样值
            Input[3] = Output[3] * CalGain - CalOffset;     //电网电压采样值
            Input[9] = Output[9] * CalGain - CalOffset;     //并网电流采样值
            Input[10] = Output[10] * CalGain - CalOffset;   //直流电流采样值
            Input[11] = Output[11] * CalGain - CalOffset;   //交流负载电流采样值
        }
    PieCtrlRegs.PIEACK.all = 0x0001;            //响应PIE同组中断
    AdcRegs.ADCST.bit.INT_SEQ1_CLR = 1;         //清除ADC中断标志位
    AdcRegs.ADCTRL2.bit.SOC_SEQ1 = 1;           //立即启动下一次转换
    EINT;
}

interrupt void sciatxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        SciaRegs.SCITXBUF = sciatxbuf[i];
    SciaRegs.SCIFFTX.bit.TXINTCLR = 1;           //清除中断标志
    PieCtrlRegs.PIEACK.all |= 0x0100;            //响应同组其他中断
}
interrupt void sciarxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        sciarxbuf[i] = SciaRegs.SCIRXBUF.all;
    SciaRegs.SCIFFRX.bit.RXFFOVRCLR = 1;
    SciaRegs.SCIFFRX.bit.RXFFINTCLR = 1;
    PieCtrlRegs.PIEACK.all |= 0x1000;
}
interrupt void scibtxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        ScibRegs.SCITXBUF = scibtxbuf[i];
    ScibRegs.SCIFFTX.bit.TXINTCLR = 1;           //清除中断标志
    PieCtrlRegs.PIEACK.all |= 0x0100;            //响应同组其他中断
}
interrupt void scibrxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        scibrxbuf[i] = ScibRegs.SCIRXBUF.all;
    ScibRegs.SCIFFRX.bit.RXFFOVRCLR = 1;
    ScibRegs.SCIFFRX.bit.RXFFINTCLR = 1;
    PieCtrlRegs.PIEACK.all |= 0x1000;
}

interrupt void spitxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        SpiaRegs.SPITXBUF = spitxbuf[i];
    SpiaRegs.SPIFFTX.bit.TXFFINTCLR = 1;        //清除中断标志
    PieCtrlRegs.PIEACK.all |= 0x0020;           //响应同组其他中断
}
interrupt void spirxfifo_isr(void)
{
    Uint16 i;
    for(i=0;i<8;i++)
        spirxbuf[i] = SpiaRegs.SPIRXBUF;
    SpiaRegs.SPIFFRX.bit.RXFFOVFCLR = 1;
    SpiaRegs.SPIFFRX.bit.RXFFINTCLR = 1;
    PieCtrlRegs.PIEACK.all |= 0x0020;
}

interrupt void ecanrx_isr(void)
{
    while(ECanaRegs.CANRMP.all != 0x00010000);
    ECanaRegs.CANRMP.all = 0x00010000;
    ecanrxbuf[0] = ECanaMboxes.MBOX16.MDL.all;
    ecanrxbuf[1] = ECanaMboxes.MBOX16.MDH.all;
    PieCtrlRegs.PIEACK.bit.ACK9 |= 1;
}
